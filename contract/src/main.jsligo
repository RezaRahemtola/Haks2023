#import "errors.jsligo" "Errors"
#import "parameters.jsligo" "Parameters"
#import "storage.jsligo" "Storage"
#import "utils.jsligo" "Utils"

type parameters = Parameters.t;
type storage = Storage.t;
type return_ = [list<operation>, storage];

const burn_address = "tz1burnburnburnburnburnburnburjAYjjX" as address;

const registerAsAssociation = (params: Parameters.register_association, store: storage): return_ => {
  assert_none_with_error(Map.find_opt(Tezos.get_sender(), store.associations), Errors.already_registered);
  assert_none_with_error(Map.find_opt(Tezos.get_sender(), store.associations), Errors.already_registered_donator);

  return [
    list([]), {...store, 
      associations: Map.add(Tezos.get_sender(), {
        stakedAmount: 0 as tez,
        name: params.name
      }, store.associations)
    }
  ];
}

const getStakeForAssociation = (associationAddress: address, store: storage): tez => {
  let donator = Big_map.find_opt(Tezos.get_sender(), store.donators);
  if (Option.is_none(donator)) {
    return 0 as tez;
  }

  let stake_data: option<tez> = Map.find_opt(associationAddress, Option.unopt(donator));
  if (Option.is_none(stake_data)) {
    return 0 as tez;
  }

  return Option.unopt(stake_data);
}

const getOrCreateDonator = (store: storage): Storage.donator => {
  let donator = Big_map.find_opt(Tezos.get_sender(), store.donators);

  if (Option.is_some(donator)) {
    return Option.unopt(donator);
  }
  return Map.empty;
}

const offerStake = (params: Parameters.offer_stake, store: storage): return_ => {
  assert_with_error(Tezos.get_amount() > (0 as tez), Errors.no_token);
  assert_none_with_error(Map.find_opt(Tezos.get_sender(), store.associations), Errors.not_donator);

  let opt = Map.find_opt(params.associationAddress, store.associations);
  assert_some_with_error(opt, Errors.not_association);

  let donator = getOrCreateDonator(store);
  let association = Option.unopt(opt);
  let amount_staked: tez = getStakeForAssociation(params.associationAddress, store);

  return [list([]), {...store,
    totalStaked: store.totalStaked + Tezos.get_amount(),
    associations: Map.update(params.associationAddress, Some({
      ...association,
      stakedAmount: association.stakedAmount + Tezos.get_amount(),
    }), store.associations),
    donators: Big_map.update(Tezos.get_sender(), Some(
      Map.update(params.associationAddress, Some(amount_staked + Tezos.get_amount()), donator)
    ), store.donators)
  }];
}

const retractStake = (params: Parameters.retract_stake, store: storage): return_ => {
  assert_none_with_error(Map.find_opt(Tezos.get_sender(), store.associations), Errors.not_donator);

  let opt = Map.find_opt(params.associationAddress, store.associations);
  assert_some_with_error(opt, Errors.not_association);

  let donator = getOrCreateDonator(store);
  let association = Option.unopt(opt);
  let amount_staked: tez = getStakeForAssociation(params.associationAddress, store);
  assert_with_error(amount_staked > (0 as tez), Errors.no_stake);

  return [list([

  ]), {...store,
    totalStaked: Utils.substract_tezos(store.totalStaked, amount_staked),
    associations: Map.update(params.associationAddress, Some({
      ...association,
      stakedAmount: Utils.substract_tezos(association.stakedAmount, amount_staked),
    }), store.associations),
    donators: Big_map.update(Tezos.get_sender(), Some(
      Map.update(params.associationAddress, None(), donator)
    ), store.donators)
  }];
}

const retractAll = (store: storage): return_ => {
  return [list([]), {...store}];
}

const claimFees = (store: storage) => {
  assert_with_error(Tezos.get_sender() == store.ownerAddress, Errors.not_owner);
  // TODO: Calculate fees
  //assert_with_error(store.totalFees > (0 as tez), no_fees);

  return [
    list([]), {...store}
  ];
}

const changeOwner = (params: Parameters.change_owner, store: storage): return_ => {
  Utils.assert_is_owner(store);
  assert_with_error(params.ownerAddress != store.ownerAddress, Errors.already_owner);
  assert_with_error(params.ownerAddress != burn_address, Errors.invalid_address);

  return [
    list([]), {...store, ownerAddress: params.ownerAddress}
  ];
}

const changeBaker = (params: Parameters.change_baker, store: storage): return_ => {
  assert_with_error(Tezos.get_sender() == store.ownerAddress, Errors.not_owner);
  assert_with_error(params.baker != store.baker, Errors.already_baker);

  return [
    list([
      Tezos.set_delegate(Some(params.baker))
    ]), {...store, baker: params.baker}
  ];
}

const main = (action: parameters, store: storage) : return_ => {
  return match (action, {
        RegisterAsAssociation: (p: Parameters.register_association) => registerAsAssociation(p, store),
        OfferStake: (p: Parameters.offer_stake) => offerStake(p, store),
        RetractStake: (p: Parameters.retract_stake) => retractStake(p, store),
        RetractAll: () => retractAll(store),
        ChangeOwner: (p: Parameters.change_owner) => changeOwner(p, store),
        ChangeBaker: (p: Parameters.change_baker) => changeBaker(p, store),
        ClaimFees: () => claimFees(store),
    });
};

// TODO: Asso claim, emit events, guard Tezos.get_amount(), separate files
